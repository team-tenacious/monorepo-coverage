import * as core from '@actions/core';
import * as exec from '@actions/exec';
import * as io from '@actions/io';
import fs from "fs/promises";
import path from 'path';
import axios from 'axios';

import RunnerFactory from './factories/runner-factory.js';

const rootExclusive = async (root) => {
  const workspacePackages = core.getInput(
    'PACKAGES', { required: true, trimWhitespace: true }
  )?.split(/(?<!(?:$|[^\\])(?:\\\\)*?\\),/).map(item => item.replace("\\,", ","));

  return await RunnerFactory.getRootRunner(root, workspacePackages).getPackagesCoverage();
}

async function downloadImage(url, filepath) {
  const response = await axios({
      url,
      method: 'GET',
      responseType: 'stream'
  });

  const data = response.data;
  await fs.writeFile(filepath, data);
}

const runAction = async () => {
  try {
    const root = core.getInput('ROOT', { required: true, trimWhitespace: true }) || ".";
    const coverages = await rootExclusive(root);

    const coverageBranch = core.getInput("COVERAGE_BRANCH", { required: false, trimWhitespace: true });
    if (coverageBranch !== "") {
      const token = core.getInput("GITHUB_TOKEN", { required: true, trimWhitespace: true });

      const originalBranch = process.env.GITHUB_REF_NAME;
      const latestCommitId = process.env.GITHUB_SHA;

      const oldPath = path.resolve(originalBranch, "old", latestCommitId);
      const latestPath = path.resolve(originalBranch, "latest");

      try {
        await exec.exec("git stash");
      } catch(e) {}

      try {
        await exec.exec("git switch", [coverageBranch]);
      } catch(e) {
        await exec.exec("git switch", ["--orphan", coverageBranch]);
      }

      try {
        await exec.exec("git pull", ["origin", coverageBranch]);
      } catch(e) {}

      await io.mkdirP(oldPath).catch(() => {});
      await io.rmRF(path.resolve(latestPath, "*")).catch(() => {});
      await io.mkdirP(latestPath).catch(() => {});

      for (const packageCoverage  of coverages) {
        await fs.writeFile(packageCoverage.json(oldPath), JSON.stringify(packageCoverage.coverage, null, 2));
        await fs.writeFile(packageCoverage.json(latestPath), JSON.stringify(packageCoverage.coverage, null, 2));

        await downloadImage(
          `https://img.shields.io/badge/${packageCoverage.name.replaceAll("-", "--")}-${packageCoverage.coverage.totalCoverage}%25-brightgreen`,
          packageCoverage.badge(latestPath)
        );

        await exec.exec("cp", [packageCoverage.badge(latestPath), packageCoverage.badge(oldPath)]);

        await exec.exec("git add", [packageCoverage.json(oldPath)]);
        await exec.exec("git add", [packageCoverage.badge(oldPath)]);
        await exec.exec("git add", [packageCoverage.json(latestPath)]);
        await exec.exec("git add", [packageCoverage.badge(latestPath)]);
      }

      await exec.exec("git config", ["http.sslVerify", false]);
      await exec.exec("git config", ["--local", "user.email", "github-actions[bot]@users.noreply.github.com"]);
      await exec.exec("git config", ["--local", "user.name", "github-actions[bot]"]);

      await exec.exec("git commit", ["-m", "autogenerated coverage"]);

      await exec.exec("git push", [`https://${process.env.GITHUB_ACTOR}:${token}@github.com/${process.env.GITHUB_REPOSITORY}.git`]);

      await exec.exec("git switch", [originalBranch]);

      try {
        await exec.exec("git stash pop");
      } catch(e) {}
    }

    core.setOutput("COVERAGE", JSON.stringify(coverages));
  } catch (error) {
    console.log(error.stack);
    core.setFailed(error.message);
  }
}

if (!process.env.GITHUB_REF.startsWith("refs/pull")) {
  await runAction();
}
